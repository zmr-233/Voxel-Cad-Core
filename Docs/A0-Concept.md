# Concept 概念与原理

## Part1 | LittleTiles 存储格式与原理

LittleTiles 在 Minecraft 正方形方块内部建立局部坐标系，把方块分割为 `2^n × 2^n × 2^n` 个子立方体。对于普通子方块，只需记录包围盒的最小点 `minXYZ` 与最大点 `maxXYZ` 即可。斜面则通过记录八个角点在 X、Y、Z 轴方向的偏移量来描述形状变化。

其中，`TransformableBox` 继承自 `LittleBox`，额外增加一个长度可变的 `data` 数组，用于存储翻转状态和角点偏移。`data[0]` 使用 32 位整数最高位作为魔数，接着 6 位记录六个面的翻转标志，再用剩余 24 位表示八个角点是否在各轴有偏移。后续元素将所有非零偏移量打包，每两个 16 位的偏移量合并为一个 32 位整数，实现压缩存储。

#### 解析流程：

首先读取 `data[0]`，提取最高位确认标记，然后右移获取翻转标志 `Flipped`。通过遍历 8 个角点和 X、Y、Z 三个轴，判断对应位是否为 1，若是，则从后续打包数据中依次解出 16 位偏移值。

#### 编码流程：

反向操作时，遍历每个角点和轴，将非零偏移写入临时列表并在标志位中打上标记；然后根据数据长度计算需要的存储单元数，将偏移值两两合并为 32 位，并将首字构造完成，得到完整的 `data` 数组。

顶层的 `LittleBlueprint` 除了包含子组 `LittleGroup`、材质与颜色分组、方块计数和定位信息外，还负责在序列化时将这些元数据写回根 `NBTCompound`，保持与原生 LittleTiles 格式完全兼容。

---

## Part2 | Voxel Definition

  隐藏的假设：体素用来处理和空间相关的事物

  体素可以从如下两条充分非必要定义出发：

  1. 均匀离散空间：独立于底层数据结构类型(Octree/Vec3)，在空间中以均匀方式分割并离散化的单元即可视为体素，体素仅提供拓扑访问（包含空间分割关系），
  2. 体素携带数据：体素是承载数据的空间单元/容器，数据体可以包含各种维度的数据（几何/纹理/物理），体素的大小和分辨率由其承载的数据体的粒度决定，而非绝对的空间尺寸

  从这两个新的定义出发获得的概念：

  1. 如何定义体素空间分辨率：体素的分辨率被定义为“相对概念”——即不再拥有绝对的尺寸大小，至此"体素的大小"实际上则由其承载的"数据体"所定义
  2. 体素底层数据结构的选择：这个问题实际上已经超出了定义的范畴，仅作简要讨论。在当前定义方式下，Octree体素只有第一层直接子节点被视为体素，其余子节点被消解为内部数据体完全独立的递归；巨大Vec3在当前定义下可视作最直接的数据结构，修改方便适合变化频繁的结构，但 由于空间的稀疏特性，一定不是最好方式；HashMap<Int3, Data>间接哈希映射可解决空白空间的浪费问题，但忽略数据的局部性，缓存不友好；Morton/Z-order 索引兼顾了数据局部性 & 缓存友好，但更适合静态结构；
因此，不应该一棒子打死只用一种数据结构，对于不同适应场景应使用最适合数据结构，多种数据结构混合存在和组合；
  3. 如何解决多分辨率下的数据处理：元数据可以显式记录分辨率，可以统一和对齐到同一分辨率在处理，也可以设计算法递归处理差异分辨率
  4. 如何解决多种数据结构混合的兼容性&一致性问题：通过设计一个抽象层，确保各种底层结构可以统一访问和操作拓扑数据，并取得所承载的数据，同时具有兼容性和高扩展性；
  5. 体素与数据体是什么关系： 数据体在这里指的是“体素承载的数据”，即所有被体素单元所包含的信息，包含了空间、纹理、属性等多维度数据，并非所有类型的数据都必须是体素的一部分，体素的核心作用是承载与空间位置相关联的数据，是一个数据容器，在某些情况下，体素本身可承载额外的几何信息或额外的物理约束
  6. 如何定义体素内结构：无论是对内部空间的再次体素分割，还是在内部用连续坐标，均被视为"体素所承载的数据"而完全独立于体素本身；因此在特定情况下，体素实际上可作为一种递归结构，能具有无限细分分辨率，并为"自适应结构"提供可能
  7. 如何定义跨体素结构：数据上严格视作由自下往上，自局部到整体的组合，而逻辑上允许构建加速结构自上而下访问&修改；总体采用分治的思想，将体素分成小的子体素块，局部结构先行计算并优化，再通过全局结构加速整体计算，既能保证局部数据的精细化处理，也能通过全局结构提高整体数据访问的效率
  8. 跨体素数据传递是否会更困难：是的，会更加困难；在分治思想下理想状态的体素都应该具有完全的独立子结构，这因此让跨体素数据传递的复杂度转嫁到加速结构的设计上，不过这得以获得极高的并行+加速结构log_N(x)快速收敛的可能性

#### 🔻对于GPT所提出的潜在问题的回复：
  1. 现实空间的分布可"不均匀"？如何解决场景本身的稀疏/分布不均匀？：在当前版本的严格定义中，看似只能先用一层低分辨率体素，并再在其所承载的数据上又叠加一层体素；
目前看来，高低分辨率差异都只能由递归解决。
但是在实际工程化下，例如GPU侧并行，由于线程的栈/寄存器都严重首先，可能最后只有最顶层体素能获得线程级别并行
理想状态不仅希望体素在空间上均匀，也希望在"数据上均匀"，但这不太可能，意味着有些线程任务轻松，而有些线程却要处理复杂递归，目前没有想出良好解决办法（可能类似`flatten`展平嵌套数组，展平递归结构到一维会是一个思路）
不过从"体素具有相对分辨率"的角度出发，当全局的所有体素的数据量偏高/偏低的时候，可能离线式全局重拓扑，重新按照新的相对分辨率把所有全局数据重新排列，但这代价一定极其高昂，就谈不上自适应了
这个问题解决方案未知
  2. “数据体”是否只指代某一特定类型的数据，还是可以是多种数据类型的混合：这也是一个工程化的问题，这里我更倾向于Bevy ECS的思想——认为各种类型的数据都是"体素在一类System下的一个Component"，那么体素就实现了定义1所描述的唯一作用就是"提供一个索引"，SOA 式并行友好、缓存友好，能确保RenderSystem不会在体素访问到其他System才使用的数据，因此该问题解决方案已知
  3. 如何处理不同分辨率的体素间的跨越问题：如果理论所讨论的只有顶层全局同精度的体素层，那么当出现"不同分辨率"体素层，说明体素在内部发生了递归，目前我只能想到"元数据显式记录分辨率GRID=N，统一&对齐到同一分辨率再操作"的方法，不过这会导致任何操作都要先对齐颗粒度再进行，肯定算不上是高效的方法，解决方案未知
  4. 如何解决抽象层会带来的性能损失问题：这也是一个十分令人头疼的问题，比如该抽象层也许能通过flatten_map返回展平嵌套后的迭代器，但对于GPU侧并行来说，肯定是称不上高效的；因此最好这种嵌套能在内存对齐上就展平了，无需调用flatten_map，不过这意味着这个抽象层的底层会引入极高的复杂度，更别提其实现这个抽象层的数据结构还有可能不是Vec3，而是Octree/Morton/Z-order之类，解决方案未知
  5. 如何解决递归结构带来的额外复杂度&性能损失：这和问题4本质上是同一个问题，解决方案未知 （大量并行，也许在CPU侧并行上还得手写类似于CPS优化，只是显式递归改延续，减少函数调用爆栈风险）
  6. 分治难以在实践中高效保证局部&全局协调（即如何跨体素间传递数据）：没有具体的情况和情景来分析，解决方案未知
  7. 如何解决多分辨率转换的误差积累：当分辨率越小时，对实际计算结果的"贡献"也越小，当不使用如问题3的"元数据显式记录GRID=N分辨率"的办法，可能对于渲染系统是一个天然的LOD（远距离下直接不访问子结构），对于物理系统这高分辨率误差作为高次无穷小也不见得是坏事，实际误差有待验证
